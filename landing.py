import streamlit as st
import pandas as pd 
import seaborn as sns
import matplotlib.pyplot as plt 
import plotly.express as px


def load_token_transfers():
    df = pd.read_csv('data/token_transfers.csv')
    df['USD_PRICES'] = df['AMOUNT'] * df['PRICE']
    return df

def load_evidence():
    df = pd.read_csv('data/evidence.csv')
    df['BLOCK_TIMESTAMP'] = pd.to_datetime(df['BLOCK_TIMESTAMP'])
    df['ASSET1_USD'] = df['ASSET1_AMOUNT'] * df['ASSET1_PRICE']
    df['ASSET2_USD'] = df['ASSET2_AMOUNT'] * df['ASSET2_PRICE']

    df['dummy'] = 1
    return df

def get_USD(evidence):
    d = evidence.fillna(0).groupby(['SENDER','MSG_KEY','ASSET1_SYMBOL','ASSET2_SYMBOL'])[['ASSET1_USD','ASSET2_USD']].sum().reset_index()

    d = pd.concat([d[['SENDER','MSG_KEY','ASSET1_SYMBOL','ASSET1_USD']].rename({'ASSET1_SYMBOL':'ASSET_SYMBOL','ASSET1_USD':'ASSET_USD'},axis=1),d[['SENDER','MSG_KEY','ASSET2_SYMBOL','ASSET2_USD']].rename({'ASSET2_SYMBOL':'ASSET_SYMBOL','ASSET2_USD':'ASSET_USD'},axis=1)],ignore_index=True)

    d = d.groupby(['SENDER','MSG_KEY'])['ASSET_USD'].sum().sort_values(ascending=False)

    d = d.reset_index().pivot(index='SENDER',columns='MSG_KEY',values='ASSET_USD').fillna(0)

    d = d.loc[d.sum(1).sort_values(ascending=False).index]

    d['gain'] = d['tokens_out'] - d['tokens_in']

    return d#.query('(tokens_in>0) and (tokens_out>0)').sort_values('gain',ascending=False)

def landing_page():
    st.image('https://openseauserdata.com/files/e22c98856cf40d4efb9d2dcb69d25c9b.png')
    st.markdown("""## Bug Exploiters
supported by GodMode by FlipsideCrypto""")
    
    df = load_evidence()
    ser = df['SENDER'].value_counts()
    d = get_USD(df)
    df_token = load_token_transfers()
    
    st.markdown(
        f"""
        On June 8th, a critical bug was found on Osmosis that led to the theft of several million dollars from liquidity pools. In an effort to help provide the Osmosis team with important data, we’ve curated these flash bounties to surface metrics that the team has requested. The upgrade that contained the exploited bug occurred at block height 4707300, and the chain was halted at block 4713064.
Of those who took advantage of the exploit, 
4 entities are responsible for over 95% of the realized exploit amount.

## What is the list of addresses that were explicitly exploiting the bug by doing multiple join/exits, i.e. who were the attackers? 
These Addresses were doing multiple joins and exists.
In total there were {ser.shape[0]} addresses doing joins and exists. Top 12 did each over 20 transactions (join or exit)
""")
    
    option_txnumber = st.number_input('Minimum number of transactions', 
                                      min_value=ser.min(), 
                                      max_value=ser.max(),
                                      value=20)
    option_usd = st.number_input('Minimum number of profit', 
                                      min_value=0, 
                                      max_value=100000,
                                      value=1000,
                                      step=100)
    data = ser[ser>=option_txnumber]
    idx = data.index.unique()
    query_df = df.query('SENDER in @idx').sort_values(['BLOCK_ID','SENDER'])
    l, r = st.columns(2)
    with l:
        st.write(f"{data.shape[0]} addresses with at least {option_txnumber} transactions")
        st.dataframe(data)
    with r:
        st.write(f"Addresses that gained at least {option_usd} USD:")
        gain_d = d.loc[data.index,['gain','tokens_in','tokens_out']].rename({'gain':'USD_gain','tokens_in':'USD_value_in','tokens_out':'USD_value_out'},axis=1).query('USD_gain>@option_usd')
        st.dataframe(gain_d)          
    with st.expander("Show transactions"):
        l1,r1 = st.columns(2)
        with l1:
            options_radio = st.radio('Select',(f'At least {option_txnumber} transactions',
                                      f'At least {option_usd} USD:'))
        with r1:
            if options_radio[-1] == 's':
                options_senders_expander = idx
            else:
                options_senders_expander = gain_d.index.unique()
            # st.write(options_senders_expander.tolist())
            option_senders_expander = st.multiselect('Select Address for Transactions', options_senders_expander, default=None)
        #st.write(option_senders_expander)
        st.dataframe(query_df.query('SENDER in @option_senders_expander'))
    options_senders = data.index
    l, r = st.columns(2)
    with l:
        option_senders = st.multiselect('Select Address', options_senders, default=data.index[0])

    plot_data = query_df.query('SENDER in @option_senders').fillna('')
    options_assets = plot_data[['ASSET1_SYMBOL','ASSET2_SYMBOL']].melt().dropna()['value'].unique()
    options_assets = [i for i in options_assets if i !='']
    with r:
        option_assets = st.multiselect('Select Assets', options_assets, default=options_assets)

    if (option_assets is not None) and (option_assets != ''):
        asset_idx = plot_data[['ASSET1_SYMBOL','ASSET2_SYMBOL']].reset_index().melt(id_vars='index')
        asset_idx = asset_idx.query('value in @option_assets')['index'].unique()
        plot_data = plot_data.loc[asset_idx] 
        
    if plot_data.shape[0]>0:
        fig = px.scatter(plot_data, 
                         x="BLOCK_TIMESTAMP", 
                         y="MSG_KEY", 
                         color="SENDER",
                        color_discrete_sequence=px.colors.qualitative.G10,
                        template='simple_white',
                    hover_data=['SENDER','MSG_KEY','BLOCK_TIMESTAMP',
       'ASSET1_SYMBOL', 'ASSET1_AMOUNT', 'ASSET2_SYMBOL', 'ASSET2_AMOUNT',
       'TX_ID'],width=800, height=400)
        fig.update_layout(legend=dict(
                        yanchor="top",
                        y=-1.1,
                        xanchor="left",
                        x=0.01
                        ))
        st.plotly_chart(fig)

    for row in plot_data['SENDER'].unique():
        st.markdown(f'{row} in [MintScan](https://www.mintscan.io/osmosis/account/{row})')
    
    
    
    
    st.markdown(
f"""

## What was the total dollar amount that was taken by the attackers? 

Total amount of addresses that gained at least {option_usd}: {gain_d['USD_gain'].sum():.0f} USD
""")
    #with st.expander('Show Breakdown per Address (selected)'):
    #   st.dataframe(d.query('SENDER in @options_senders').reset_index()) 
    st.markdown("""## What amount of stolen assets in the attackers’ wallets remain on Osmosis?
        """ 
    )
    a = data.index
    l,r = st.columns(2)
    with l:
        st.write('Transfers in and out of Osmosis')    
        st.dataframe(df_token.query('SENDER in @a')['TRANSFER_TYPE'].value_counts())
    with r:
        st.markdown(f"""sent out of Osmosis {df_token.query('SENDER in @a')['USD_PRICES'].sum():.0f}""")
        st.markdown(f"""still possibly remaining in Osmosis {gain_d['USD_gain'].sum() - df_token.query('SENDER in @a')['USD_PRICES'].sum():.0f}""")
    with st.expander('Show Transactions'):
        st.dataframe(df_token.query('SENDER in @a'))
    
    st.markdown("""## Conclusion
We find 7 Addresses that have done more than 20 join/exit pools and have managed to gain while doing so.   
In total this translates to 3.64M USD
Of thse assets there is still 377k USD inside Osmosis while 3.2M USD have been bridged out.

### Queries used
[token transfers](https://app.flipsidecrypto.com/velocity/queries/36d8a68a-781e-45b0-80bb-f631d96419ab)
[pool joins](https://app.flipsidecrypto.com/velocity/queries/e0e1377a-749e-4588-a41e-1d65a7d5d5ce)

### Github
[kkpsiren/Bug_Exploiters](https://github.com/kkpsiren/Bug_Exploiters)
    """)